---
date_created: 2024-06-10 14:05
author: 
date_published: 
url:
---
# 모듈 9 컨테이너

# 마이크로서비스

![](Pasted%20image%2020240610140648.png)

## 밀결합된 애플리케이션의 안티 패턴

- 웹 서버와 애플리케이션 서버가 밀결합되어 있음
- 웹 서버가 애플리케이션 서버의 내부 구현을 알아야 함
- 애플리케이션 서버를 추가할 때 웹 서버 구성을 변경해야 함

## 느슨하게 결합된 애플리케이션

- 로드 밸런서를 사용하여 웹 서버와 애플리케이션 서버를 분리
- 웹 서버는 로드 밸런서의 주소만 알면 됨
- 애플리케이션 서버 추가 시 웹 서버 구성 변경 불필요

## 마이크로서비스와 모놀리식 애플리케이션 비교

![](Pasted%20image%2020240610140815.png)

## 모놀리식 애플리케이션

- 모든 기능이 하나의 큰 애플리케이션으로 구성됨
- 사용자, 주제, 메시지 로직이 하나의 실행 파일로 빌드되고 배포됨
- 작은 규모의 애플리케이션에는 적합

## 마이크로서비스 애플리케이션

- 기능을 독립적인 서비스로 분리
  - 사용자 서비스
  - 주제 서비스
  - 메시지 서비스
- 각 서비스는 다른 컴퓨팅 서비스와 언어로 구현 가능
  - 사용자 서비스: AWS Lambda, Python
  - 주제 서비스: EC2, Java
  - 메시지 서비스: 컨테이너, .NET
- 독립적으로 확장 가능
- 팀 구성을 마이크로서비스 중심으로 할 수 있음
- 새로운 개발자는 특정 서비스만 학습하면 됨

## 마이크로서비스의 장점

- 독립적인 확장성
- 서비스별로 다른 기술 스택 사용 가능
- 팀 구성의 유연성
- 작은 범위의 학습 필요

## 결론

- 애플리케이션 규모가 작을 때는 모놀리식이 타당할 수 있음
- 애플리케이션과 팀의 규모가 커지면 마이크로서비스로 전환 고려

# 컨테이너

![](Pasted%20image%2020240610141129.png)

## 컨테이너의 개념

- 애플리케이션을 패키징하는 표준화된 방법
- 필요한 코드, 구성, 종속성을 포함하는 독립된 환경

## 컨테이너 이미지

- Python 애플리케이션 예시
  - pip 라이브러리 포함
  - Python 런타임 엔진 포함
  - Python 소스 코드 포함
- 한 번 생성한 이미지를 여러 번 실행 가능

## 컨테이너의 장점

- VM보다 빠른 확장
- 운영 체제의 가상화를 사용하여 빠르게 실행
- 휴대성이 뛰어남
  - 노트북과 프로덕션 환경에서 동일하게 실행 가능
![](Pasted%20image%2020240610141253.png)

## 컨테이너와 모놀리식 애플리케이션 비교

- 모놀리식 애플리케이션
  - 하나의 큰 실행 파일로 구성
  - 코드 재사용이 가능하지만 확장과 유지보수가 어려움
- 마이크로서비스
  - 분리된 서비스로 구성
  - 서비스 간 네트워크 호출을 통해 상호작용
  - 독립적인 확장과 유지보수가 가능

## 가상화 스택에서의 컨테이너 위치

![](Pasted%20image%2020240610141310.png)
- 베어 메탈 서버
  - 하드웨어에서 운영 체제를 부팅
  - 애플리케이션이 설치됨
- 가상 머신 (VM)
  - 하드웨어 위에 하이퍼바이저가 게스트 운영 체제를 부팅
  - 각 VM에 애플리케이션 설치
- Docker와 같은 컨테이너 플랫폼
  - 운영 체제 위에서 실행
  - 하나의 운영 체제를 공유하여 컨테이너를 빠르게 부팅

## AWS에서의 컨테이너 실행

![](Pasted%20image%2020240610141420.png)
- EC2 인스턴스에서 Docker를 실행하여 컨테이너 실행
- 큰 규모에서는 오케스트레이션 도구 사용

## 컨테이너 오케스트레이션 도구

- 스케줄링: 컨테이너를 호스팅할 인스턴스를 결정
- 배치: 인스턴스에 컨테이너 배포
- 네트워킹: 애플리케이션 엔드포인트 생성 및 통신 관리
- 모니터링: 로그 수집, CPU 및 메모리 사용량 모니터링, 리소스 관리

## 컨테이너 오케스트레이션의 주요 기능

- 컨테이너 간 통신 관리
- 중앙 집중식 로그 수집
- CPU와 메모리 사용량 모니터링 및 리소스 관리

# 컨테이너 서비스

![](Pasted%20image%2020240610141618.png)

## 컨테이너 레지스트리

![](Pasted%20image%2020240610141653.png)

### Amazon Elastic Container Registry (ECR)

- 컨테이너 이미지를 푸시할 수 있는 곳
- 노트북에서 작성한 애플리케이션을 Docker 이미지로 변환 후 ECR로 푸시 가능

## 오케스트레이션 도구

![](Pasted%20image%2020240610141754.png)
### Amazon Elastic Kubernetes Service (EKS)와 Amazon Elastic Container Service (ECS)

- 컨테이너를 호스트에 배포하는 방법 제공
- EKS와 ECS를 통해 오케스트레이션 작업 수행 가능

### AWS Fargate

- 서버리스 옵션
- 컨테이너를 실행할 호스트를 관리하거나 구성할 필요 없음
- 오케스트레이션 도구를 구성하여 Fargate에서 컨테이너 시작 가능

### EC2 인스턴스에서 컨테이너 실행

- 사용자 계정의 EC2 인스턴스에서 컨테이너 실행 옵션 제공

## 모놀리식 애플리케이션 분리

![](Pasted%20image%2020240610141917.png)

### 분리된 서비스

- 사용자 서비스, 주제 서비스, 메시징 서비스로 분리
- 각 팀은 컨테이너 이미지를 만들고 Docker 빌드를 통해 이미지를 생성

### ECR 정책

- 특정 사용자만 이미지를 푸시하거나 가져올 수 있도록 구성 가능

## Amazon ECS 사용

### 서비스와 태스크 정의

- ECS에서 서비스 생성 시 태스크 정의 포함
- 태스크는 실행할 이미지를 지정
- 서비스에 대한 로드 밸런서를 구성하여 서비스 제공

### ECS 클러스터와 확장성

- 컨테이너를 호스트에 배포
- EC2 인스턴스 또는 서버리스 옵션인 Fargate를 사용하여 배포 가능
- 서비스 용량을 자동으로 확장

### 완전관리형 서비스

- ECS 컨트롤 플레인은 AWS가 관리
- DNS를 통해 기본 서비스 검색 제공
- CloudWatch Logs로 로그 전송 가능

### CI/CD 통합

- 지속적인 통합 및 배포 환경과 잘 통합
- 노트북에서 커밋 후 전체 프로세스 자동화 가능

### 애플리케이션 로드 벨런서

- 애플리케이션 로드 벨런서를 생성하고 서비스를 등록
- 로드 벨런서 내에서 서비스를 구성하여 대상 그룹 생성

### 모니터링과 자동화

- 컨테이너 모니터링, CPU 및 메모리 사용량 모니터링
- 중앙집중식 위치로 메트릭 전송

## Kubernetes 사용

### Kubernetes 개요

- 대규모 애플리케이션 실행을 위한 오픈소스 프로젝트
- 원하는 상태 원칙에 따라 작동
- 다양한 환경에서 실행 가능

### AWS에서의 Kubernetes 서비스
![](Pasted%20image%2020240610144444.png)
- Amazon EKS 제공
- EKS는 컨트롤 플레인을 관리
- 파드, 디플로이먼트, 서비스 등의 오브젝트로 구성

### EKS와 클라우드 통합

- 로드 밸런싱된 서비스 제공
- 컨테이너 배포 시 노드 그룹이나 Fargate 사용 가능

### 서버리스 환경

- AWS Fargate 사용 시 호스트 관리 불필요
- EC2 인스턴스에 배포하여 세밀한 호스트 관리 가능

## 요약

### 오케스트레이션 서비스 선택

- ECS 또는 EKS 선택 가능
- EKS는 Kubernetes 기반

### 호스팅 유형 선택

- 서버리스 제품인 AWS Fargate
  - AWS가 호스트 관리
- 사용자 계정의 EC2 인스턴스
  - 사용자 호스트 관리
